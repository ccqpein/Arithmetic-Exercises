(defun min-number-operations (target)
  ;;(operation-helper target 0)
  (operation-helper2 target)
  )

(defun operation-helper (arr base)
  (cond ((not arr) 0)
        ((= 1 (length arr)) (- (car arr) base))
        (t (let ((min (apply #'min arr)))
             (+ (- min base)
                (loop
                  for i in (mapcar (lambda (x) (operation-helper x min)) (split-seq arr base))
                  sum i))))))

(defun operation-helper2 (arr)
  (loop
    with result = (car arr) and cache = (car arr)
    for i in (cdr arr)
    do (incf result (max (- i cache) 0))
    do (setf cache i)
    finally (return result)
    ))

(defun split-seq (l ele)
  (let (result cache)
    (do ((rest l (cdr rest))
         )
        ((not rest) (reverse (cons (reverse cache) result)))
      (if (= ele (car rest))
          (setf result (cons (reverse cache) result)
                cache nil)
          (push (car rest) cache)))))

(defun main ()
  (assert (= 3 (min-number-operations '(1 2 3 2 1))))
  (assert (= 4 (min-number-operations '(3 1 1 2))))
  (assert (= 7 (min-number-operations '(3 1 5 4 2))))
  (assert (= 1 (min-number-operations '(1 1 1 1))))
  (assert (= 8 (min-number-operations '(3 4 2 5 6))))
  (assert (= 5 (min-number-operations '(5 5 3))))  )
