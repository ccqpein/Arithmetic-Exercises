(defun lcs (nums)
  (let ((nums (sort nums #'<)))
    (do ((rest-num nums (cdr rest-num))
         (a 0)
         (largest 0)
         (last)
         )
        ((eql nil rest-num)
         (progn (if (>= a largest)
                    (setf largest a))
                (return largest)))
      (cond ((eql 0 a)
             (setf a (+ 1 a)
                   last (car rest-num)))
            ((eql 1 (- (car rest-num) last))
             (setf a (+ 1 a)))
            ((eql 0 (- (car rest-num) last))
             )
            (t
             (progn (if (>= a largest)
                        (setf largest a))
                    (setf a 1))))
      (setf last (car rest-num))
      )
    )
  )
